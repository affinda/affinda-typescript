{"version":3,"file":"Import.js","sourceRoot":"","sources":["../src/Import.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,0CAA2C;AAE3C;;;GAGG;AACH,MAAa,MAAM;IACjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAqEG;IACH,8DAA8D;IACvD,MAAM,CAAC,IAAI,CAAC,UAAkB,EAAE,OAAgC;QACrE,MAAM,eAAe,GAAoC,UAAU,CAAC,OAAO,CAAC,CAAC;QAC7E,OAAO,eAAe,CAAC,UAAU,CAAC,CAAC;IACrC,CAAC;CACF;AA5ED,wBA4EC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport importLazy = require('import-lazy');\r\n\r\n/**\r\n * Helpers for resolving and importing Node.js modules.\r\n * @public\r\n */\r\nexport class Import {\r\n  /**\r\n   * Provides a way to improve process startup times by lazy-loading imported modules.\r\n   *\r\n   * @remarks\r\n   * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}\r\n   * package.  It enables you to replace an import like this:\r\n   *\r\n   * ```ts\r\n   * import * as example from 'example'; // <-- 100ms load time\r\n   *\r\n   * if (condition) {\r\n   *   example.doSomething();\r\n   * }\r\n   * ```\r\n   *\r\n   * ...with a pattern like this:\r\n   *\r\n   * ```ts\r\n   * const example: typeof import('example') = Import.lazy('example', require);\r\n   *\r\n   * if (condition) {\r\n   *   example.doSomething(); // <-- 100ms load time occurs here, only if needed\r\n   * }\r\n   * ```\r\n   *\r\n   * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus\r\n   * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,\r\n   * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.\r\n   *\r\n   * Usage guidelines:\r\n   *\r\n   * - Always specify types using `typeof` as shown above.\r\n   *\r\n   * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety\r\n   *   seriously impacts the maintainability of the code base.\r\n   *\r\n   * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:\r\n   *\r\n   * ```ts\r\n   * const example: typeof import('example') = Import.lazy('example', require);\r\n   * import type * as exampleTypes from 'example';\r\n   * ```\r\n   *\r\n   * - If the imported module confusingly has the same name as its export, then use the Module suffix:\r\n   *\r\n   * ```ts\r\n   * const exampleModule: typeof import('../../logic/Example') = Import.lazy(\r\n   *   '../../logic/Example', require);\r\n   * import type * as exampleTypes from '../../logic/Example';\r\n   * ```\r\n   *\r\n   * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted\r\n   *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function\r\n   *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is\r\n   *   better behaved.\r\n   *\r\n   * - It's recommended to sort imports in a standard ordering:\r\n   *\r\n   * ```ts\r\n   * // 1. external imports\r\n   * import * as path from 'path';\r\n   * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';\r\n   *\r\n   * // 2. local imports\r\n   * import { LocalFile } from './path/LocalFile';\r\n   *\r\n   * // 3. lazy-imports (which are technically variables, not imports)\r\n   * const semver: typeof import('semver') = Import.lazy('semver', require);\r\n   * ```\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  public static lazy(moduleName: string, require: (id: string) => unknown): any {\r\n    const importLazyLocal: (moduleName: string) => unknown = importLazy(require);\r\n    return importLazyLocal(moduleName);\r\n  }\r\n}\r\n"]}